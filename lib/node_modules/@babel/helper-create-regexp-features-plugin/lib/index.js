"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;

var _regexpuCore = _interopRequireDefault(require("regexpu-core"));

var _features = require("./features");

var _util = require("./util");

var _package = _interopRequireDefault(require("../package.json"));

var _core = require("@babel/core");

var _helperRegex = require("@babel/helper-regex");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var version = _package.default.version.split(".").reduce(function (v, x) {
  return v * 1e5 + +x;
}, 0);

var versionKey = "@babel/plugin-regexp-features/version";

function createRegExpFeaturePlugin(_ref) {
  var name = _ref.name,
      feature = _ref.feature,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;
  return {
    name: name,
    pre: function pre() {
      var _file$get;

      var file = this.file;
      var features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;
      var newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);
      var useUnicodeFlag = options.useUnicodeFlag,
          _options$runtime = options.runtime,
          runtime = _options$runtime === void 0 ? true : _options$runtime;

      if (useUnicodeFlag === false) {
        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);
      }

      if (newFeatures !== features) {
        file.set(_features.featuresKey, newFeatures);
      }

      if (!runtime) {
        file.set(_features.runtimeKey, false);
      }

      if (!file.has(versionKey) || file.get(versionKey) < version) {
        file.set(versionKey, version);
      }
    },
    visitor: {
      RegExpLiteral: function RegExpLiteral(path) {
        var _file$get2;

        var node = path.node;
        var file = this.file;
        var features = file.get(_features.featuresKey);
        var runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;
        var regexpuOptions = (0, _util.generateRegexpuOptions)(node, features);

        if (regexpuOptions === null) {
          return;
        }

        var namedCaptureGroups = {};

        if (regexpuOptions.namedGroup) {
          regexpuOptions.onNamedGroup = function (name, index) {
            namedCaptureGroups[name] = index;
          };
        }

        node.pattern = (0, _regexpuCore.default)(node.pattern, node.flags, regexpuOptions);

        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
          path.replaceWith(_core.types.callExpression(this.addHelper("wrapRegExp"), [node, _core.types.valueToNode(namedCaptureGroups)]));
        }

        if ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {
          (0, _helperRegex.pullFlag)(node, "u");
        }

        if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag)) {
          (0, _helperRegex.pullFlag)(node, "s");
        }
      }
    }
  };
}

function isRegExpTest(path) {
  return path.parentPath.isMemberExpression({
    object: path.node,
    computed: false
  }) && path.parentPath.get("property").isIdentifier({
    name: "test"
  });
}