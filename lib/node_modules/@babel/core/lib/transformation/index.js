"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runAsync = runAsync;
exports.runSync = runSync;

function _traverse() {
  var data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function _traverse() {
    return data;
  };

  return data;
}

var _pluginPass = _interopRequireDefault(require("./plugin-pass"));

var _blockHoistPlugin = _interopRequireDefault(require("./block-hoist-plugin"));

var _normalizeOpts = _interopRequireDefault(require("./normalize-opts"));

var _normalizeFile = _interopRequireDefault(require("./normalize-file"));

var _generate = _interopRequireDefault(require("./file/generate"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function runAsync(config, code, ast, callback) {
  var result;

  try {
    result = runSync(config, code, ast);
  } catch (err) {
    return callback(err);
  }

  return callback(null, result);
}

function runSync(config, code, ast) {
  var file = (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast);
  var opts = file.opts;

  try {
    transformFile(file, config.passes);
  } catch (e) {
    var _opts$filename;

    e.message = "".concat((_opts$filename = opts.filename) != null ? _opts$filename : "unknown", ": ").concat(e.message);

    if (!e.code) {
      e.code = "BABEL_TRANSFORM_ERROR";
    }

    throw e;
  }

  var outputCode, outputMap;

  try {
    if (opts.code !== false) {
      var _ref = (0, _generate.default)(config.passes, file);

      outputCode = _ref.outputCode;
      outputMap = _ref.outputMap;
    }
  } catch (e) {
    var _opts$filename2;

    e.message = "".concat((_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown", ": ").concat(e.message);

    if (!e.code) {
      e.code = "BABEL_GENERATE_ERROR";
    }

    throw e;
  }

  return {
    metadata: file.metadata,
    options: opts,
    ast: opts.ast === true ? file.ast : null,
    code: outputCode === undefined ? null : outputCode,
    map: outputMap === undefined ? null : outputMap,
    sourceType: file.ast.program.sourceType
  };
}

function transformFile(file, pluginPasses) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var pluginPairs = _step.value;
      var passPairs = [];
      var passes = [];
      var visitors = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = pluginPairs.concat([(0, _blockHoistPlugin.default)()])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var plugin = _step2.value;
          var pass = new _pluginPass.default(file, plugin.key, plugin.options);
          passPairs.push([plugin, pass]);
          passes.push(pass);
          visitors.push(plugin.visitor);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      for (var _i = 0, _passPairs = passPairs; _i < _passPairs.length; _i++) {
        var _passPairs$_i = _slicedToArray(_passPairs[_i], 2),
            _plugin = _passPairs$_i[0],
            _pass = _passPairs$_i[1];

        var fn = _plugin.pre;

        if (fn) {
          var result = fn.call(_pass, file);

          if (isThenable(result)) {
            throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
          }
        }
      }

      var visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);

      (0, _traverse().default)(file.ast, visitor, file.scope);

      for (var _i2 = 0, _passPairs2 = passPairs; _i2 < _passPairs2.length; _i2++) {
        var _passPairs2$_i = _slicedToArray(_passPairs2[_i2], 2),
            _plugin2 = _passPairs2$_i[0],
            _pass2 = _passPairs2$_i[1];

        var _fn = _plugin2.post;

        if (_fn) {
          var _result = _fn.call(_pass2, file);

          if (isThenable(_result)) {
            throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function isThenable(val) {
  return !!val && (_typeof(val) === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
}